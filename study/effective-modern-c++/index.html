<!DOCTYPE html>
<html
  dir="ltr"
  lang="ko"
  data-theme=""
  class="html"
><head>
  <title>
    
      
        Effective Modern C&#43;&#43; |

      kyungpyo-kim

  </title>

  
  <meta charset="utf-8" /><meta name="generator" content="Hugo 0.101.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="author" content="kyungpyo-kim" />
  <meta
    name="description"
    content="Effective Modern C&#43;&#43; 정리"
  />
  
    <meta name="google-site-verification" content="LOq04nTRWtf6KOjNzm_vAFYbz0fmzh0MIFnxxqX6r" />
  
    
    
    <link
      rel="stylesheet"
      href="../../scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css"
      integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o="
      crossorigin="anonymous"
      type="text/css"
    />

  

  
  <link
    rel="stylesheet"
    href="../../css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css"
    integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU="
    crossorigin="anonymous"
    type="text/css"
  />
  
  
  <link
    rel="stylesheet"
    href="../../fontawesome/css/fontawesome.min.7f3c2281c7f965ce3c64888aa452793252a0416909c181097f81d0a0f7d1624e.css"
    integrity="sha256-fzwigcf5Zc48ZIiKpFJ5MlKgQWkJwYEJf4HQoPfRYk4="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="../../fontawesome/css/solid.min.35fc032da8ede6681675d20a2f862fb9e1045c1d512d495fcf862c054daffef2.css"
    integrity="sha256-NfwDLajt5mgWddIKL4YvueEEXB1RLUlfz4YsBU2v/vI="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="../../fontawesome/css/regular.min.3b92357925ea7284f0c6b0378396f39f470f7842ed9702f337e667c4026bf837.css"
    integrity="sha256-O5I1eSXqcoTwxrA3g5bzn0cPeELtlwLzN&#43;ZnxAJr&#43;Dc="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="../../fontawesome/css/brands.min.ebb1096e1976e8cc4e2532cfa050b8f30eb13b8eb06be5cee3e38eb426b838ea.css"
    integrity="sha256-67EJbhl26MxOJTLPoFC48w6xO46wa&#43;XO4&#43;OOtCa4OOo="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link rel="shortcut icon" href="../../favicons/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="../../favicons/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="../../favicons/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="../../favicons/favicon-16x16.png" />

  <link rel="canonical" href="https://kyungpyo-kim.github.io/study/effective-modern-c&#43;&#43;/" />

  
  
  
  
  <script
    type="text/javascript"
    src="../../js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js"
    integrity="sha256-&#43;RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI="
    crossorigin="anonymous"
  ></script>

  
    
    
    <script
      type="text/javascript"
      src="../../js/anatole-theme-switcher.min.738c0e3a493854876aeab9e2316fd43f1936aeeac4cc6b3e60bb26456dba72ad.js"
      integrity="sha256-c4wOOkk4VIdq6rniMW/UPxk2rurEzGs&#43;YLsmRW26cq0="
      crossorigin="anonymous"
    ></script>

  

  


  
  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://kyungpyo-kim.github.io/images/site-feature-image.png"/>

<meta name="twitter:title" content="Effective Modern C&#43;&#43;"/>
<meta name="twitter:description" content="Effective Modern C&#43;&#43; 정리"/>



  
  <meta property="og:title" content="Effective Modern C&#43;&#43;" />
<meta property="og:description" content="Effective Modern C&#43;&#43; 정리" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kyungpyo-kim.github.io/study/effective-modern-c&#43;&#43;/" /><meta property="og:image" content="https://kyungpyo-kim.github.io/images/site-feature-image.png"/><meta property="article:section" content="study" />
<meta property="article:published_time" content="2021-08-07T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-08-07T00:00:00+00:00" /><meta property="og:site_name" content="Kyungpyo Kim" />
<meta property="og:see_also" content="https://kyungpyo-kim.github.io/study/no-raw-loops-yes-stl-algorithms-17cb7499a6464a30a9880cdc161e05b9/" />




  
  
  
  
  <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "articleSection": "study",
        "name": "Effective Modern C\u002b\u002b",
        "headline": "Effective Modern C\u002b\u002b",
        "alternativeHeadline": "",
        "description": "
      Effective Modern C\u002b\u002b 정리


    ",
        "inLanguage": "ko",
        "isFamilyFriendly": "true",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/kyungpyo-kim.github.io\/study\/effective-modern-c\u002b\u002b\/"
        },
        "author" : {
            "@type": "Person",
            "name": "Kyungpyo Kim"
        },
        "creator" : {
            "@type": "Person",
            "name": "Kyungpyo Kim"
        },
        "accountablePerson" : {
            "@type": "Person",
            "name": "Kyungpyo Kim"
        },
        "copyrightHolder" : {
            "@type": "Person",
            "name": "Kyungpyo Kim"
        },
        "copyrightYear" : "2021",
        "dateCreated": "2021-08-07T00:00:00.00Z",
        "datePublished": "2021-08-07T00:00:00.00Z",
        "dateModified": "2021-08-07T00:00:00.00Z",
        "publisher":{
            "@type":"Organization",
            "name": "Kyungpyo Kim",
            "url": "https://kyungpyo-kim.github.io/",
            "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/kyungpyo-kim.github.io\/favicons\/favicon-32x32.png",
                "width":"32",
                "height":"32"
            }
        },
        "image": 
      [
        
        "https://kyungpyo-kim.github.io/images/site-feature-image.png"


      
      ]

    ,
        "url" : "https:\/\/kyungpyo-kim.github.io\/study\/effective-modern-c\u002b\u002b\/",
        "wordCount" : "3178",
        "genre" : [ ],
        "keywords" : [ 
      
      "C\u002b\u002b"

    
      
        ,

      
      "독서"

    ]
    }
  </script>





  
  <script
  data-ad-client="ca-pub-7791328994969079"
  async
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"
></script>


</head>
<body
    
      class="body theme--light"

    
  >
    <div class="wrapper">
      <aside
        
          class="wrapper__sidebar"

        
      ><div
  class="sidebar
    animated fadeInDown

  "
>
  <div class="sidebar__content">
    <div class="sidebar__introduction">
      <img
        class="sidebar__introduction-profileimage"
        src="../../images/kyungpyo.jpeg"
        alt="profile picture"
      />
      
        <div class="sidebar__introduction-title">
          <a href="../../">Kyungpyo Kim</a>
        </div>

      
      <div class="sidebar__introduction-description">
        <p>새로운 것을 찾아</p>
      </div>
    </div>
    <ul class="sidebar__list">
      
        <li class="sidebar__list-item">
          <a
            href="https://www.linkedin.com/in/kyungpyo-kim-b0b13618a/"
            target="_blank"
            rel="noopener"
            aria-label="Linkedin"
            title="Linkedin"
          >
            <i class="fab fa-linkedin fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a
            href="https://github.com/Kyungpyo-Kim"
            target="_blank"
            rel="noopener"
            aria-label="GitHub"
            title="GitHub"
          >
            <i class="fab fa-github fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a
            href="https://instagram.com/kyung_py"
            target="_blank"
            rel="noopener"
            aria-label="instagram"
            title="instagram"
          >
            <i class="fab fa-instagram fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a
            href="mailto:kyungpyo94@gmail.com"
            target="_blank"
            rel="noopener"
            aria-label="e-mail"
            title="e-mail"
          >
            <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
    </ul>
  </div><footer class="footer footer__sidebar">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        Kyungpyo Kim 2014-2022

      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="../../js/medium-zoom.min.602bd2014468bd348112e2aa24f595c530d257a4ed6c335d7baaa6ac9a7ca6fb.js"
    integrity="sha256-YCvSAURovTSBEuKqJPWVxTDSV6TtbDNde6qmrJp8pvs="
    crossorigin="anonymous"
  ></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-150383923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</div>
</aside>
      <main
        
          class="wrapper__main"

        
      >
        <header class="header"><div
  class="
    animated fadeInDown

  "
>
  <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
  </a>
  <nav class="nav">
    <ul class="nav__list" id="navMenu">
      
      
        
        
          <li class="nav__list-item">
            <a
              
              href="../../"
              
              title=""
              >Home</a
            >
          </li>

        


      
        
        
          <li class="nav__list-item">
            <a
              
              href="../../life/"
              
              title=""
              >Life</a
            >
          </li>

        


      
        
        
          <li class="nav__list-item">
            <a
              
              href="../../study/"
              
              title=""
              >Study</a
            >
          </li>

        


      
        
        
          <li class="nav__list-item">
            <a
              
              href="../../about/"
              
              title=""
              >About</a
            >
          </li>

        


      
    </ul>
    <ul class="nav__list nav__list--end">
      
      
        <li class="nav__list-item">
          <div class="themeswitch">
            <a title="Switch Theme">
              <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
          </div>
        </li>

      
    </ul>
  </nav>
</div>
</header>
  <div
    class="post 
      animated fadeInDown

    "
  >
    
    <div class="post__content">
      <h1>Effective Modern C&#43;&#43;</h1>
      
        <ul class="post__meta">
          <li class="post__meta-item">
            <em class="fas fa-calendar-day post__meta-icon"></em>
            <span class="post__meta-text"
              >
                
                  Sat, Aug 7, 2021


                


              
            </span>
          </li>
          <li class="post__meta-item">
            <em class="fas fa-stopwatch post__meta-icon"></em>
            <span class="post__meta-text">읽는 시간 15분</span>
          </li>
        </ul>

      <hr>
<p>Effective Modern C++ 도서를 읽고 정리한 효율적인 C++ 프로그래밍 방법</p>
<p>저자: 스콧 마이어스</p>
<p>역: 류광</p>
<p>출판사: 한빛미디어</p>
<p>발간일: 2015/09/18</p>
<hr>
<hr>
<p>C++14: C++ 14 표시가 없으면 C++11, C++14 모두 해당</p>
<hr>
<h2 id="type-deduction">Type Deduction</h2>
<ul>
<li>
<p>01 <code>template</code> type deduction</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typedef</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</span></span></code></pre></div><ol>
<li>PramType이 포인터 또는 참조 형식이지만 보편 참조(&amp;&amp;)는 아님
<ul>
<li>ParamType 의 형식이 T&amp; 인경우 T는 참조성을 무시한다.</li>
</ul>
</li>
<li>PramType이 보편 참조임
<ul>
<li>expr 이 lvalue일 경우 1번과 다르게 취급한다.</li>
</ul>
</li>
<li>PramType이 포인터도 아니고 참조도 아님 (값 전달 방식)
<ul>
<li>expr 의 const, volatile 속성은 무시된다.</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 1. 참조(&amp;) 형식의 param
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span> <span class="c1">// int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// const int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// const int 인 x에 대한 참조
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T: int, param 의 형식: int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span> <span class="c1">// T: const int, param의 형식: const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span> <span class="c1">// T: const int, param의 형식: const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2. const 형식의 param
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f2</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T: int, param 의 형식: const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span> <span class="c1">// T: int, param의 형식: const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span> <span class="c1">// T: int, param의 형식: const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 3. param 이 보편 참조
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f3</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f3</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// x는 lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// T: int&amp;, param 의 형식: int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f3</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span> <span class="c1">// cx는 lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// T: const int&amp;, param의 형식: const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f3</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span> <span class="c1">// rx는 rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// T: int, param의 형식: int&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 4. param 이 포인터도 아니고 참조도 아님 (pass-by-value)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f4</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 인수의 참조(&amp;), const, volatile 형태는 무시된다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f4</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T: int, param 의 형식: int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f4</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span> <span class="c1">// T: int, param의 형식: int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f4</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span> <span class="c1">// T: int, param의 형식: int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="s">&#34;fun with pointers&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 여기서 왼쪽의 const는 문자열(char*) 이 변경 불가함을 의미한다.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 오른쪽의 const는 ptr의 포인터가 다른 곳을 가르키도록 변경이 불가함을 의미한다.
</span></span></span><span class="line"><span class="cl"><span class="c1">// (예를 들어 null로 변경이 불가)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f4</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// param 은 const 문자열(char*)을 가르키는 수정 가능한 포인터
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="c1">// ptr 포인터의 변경이 불가능한 속성(오른쪽 const)이 사라짐 
</span></span></span></code></pre></div><ul>
<li>expr 의 형식이 배열인 경우
<ul>
<li>포인터로 붕괴된다.</li>
<li>참조로 받을 경우 붕괴되지 않는다.</li>
<li><code>const char*</code> 는 배열(<code>const char[]</code>) 이 아니다!</li>
<li><code>const char[]</code> 말고 <code>std::array&lt;cahr&gt;</code> 를 쓰자!</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typedef</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typedef</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;J. P. Bridggs&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// name 의 형식은 const char[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="c1">// param 의 형식은 const char* (포인터로 붕괴)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="c1">// param 의 형식은 const char[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 위의 특성을 이용하여 배열의 크기를 알아내는 함수
</span></span></span><span class="line"><span class="cl"><span class="c1">// constexpr 는 이 함수의 호출 결과를 컴파일 도중에 사용 가능하게 한다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>uniform initialization 을 이용하는 경우</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// compile error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">f2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f2</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// T는 int 로 연역(deduction)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="c1">// param 의 형식은 std::initializer_list&lt;int&gt;
</span></span></span></code></pre></div></li>
<li>
<p>02 <code>auto</code>의 type deduction</p>
<ol>
<li>
<p>형식 지정자가 포인터나 참조 형식이지만 보편 참조는 아닌 경우</p>
</li>
<li>
<p>형식 지정자가 보편 참조인 경우</p>
</li>
<li>
<p>형식 지정자가 포인터도 아니고 참조도 아닌 경우</p>
</li>
<li>
<p>배열과 함수 이름이 포인터로 붕괴하는 경우</p>
</li>
<li>
<p>균일 초기화(uniform initialization)를 하는 경우</p>
</li>
<li>
<p>반환 형식에 또는 람다의 매개함수에 auto 형식 연역을 하는 경우 C++14</p>
<p>template type deduction 과 동일하게 작동</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 1. 3.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>        <span class="c1">// 3. x 는 포인터도 아니고 참조도 아님
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// 3. cx 는 포인터도 아니고 참조도 아님 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 1. rx 는 참조 형식
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// 2. x는 int 이자 lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">//    uref1 은 int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref2</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>  <span class="c1">// 2. cx는 const int 이자 lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">//    uref2 의 형식은 const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref3</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>  <span class="c1">// 2. 27은 int 이자 rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">//    uref3의 형식은 int&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1">// 4.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;R. N. Briggs&#34;</span><span class="p">;</span> <span class="c1">// name 의 형식은 const char[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">arr1</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>                   <span class="c1">// arr1 의 형식은 const char*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>                   <span class="c1">// arr2 의 형식은 const char (&amp;)[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func1</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span>  <span class="c1">// func1 의 형식은 void (*)(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">func2</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span> <span class="c1">// func2 의 형식은 void (&amp;)(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 5.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>          <span class="c1">// x1 의 형식은 int, 값은 27
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>           <span class="c1">// x2 의 형식은 int, 값은 27
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>      <span class="c1">// x3 의 형식은 std::initializer_list&lt;int&gt;, 값은 {27}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x4</span><span class="p">{</span><span class="mi">27</span><span class="p">};</span>           <span class="c1">// x4 의 형식은 std::initializer_list&lt;int&gt;, 값은 {27}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x5</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">};</span> <span class="c1">// compile error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                       <span class="c1">// std::initalizer_list&lt;T&gt; 의 T를 연역 할 수 없음
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 6. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">createInitList</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span> <span class="c1">// compile error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">resetV</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">v</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">newValue</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span> <span class="o">=</span> <span class="n">newValue</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">resetV</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// compile error
</span></span></span></code></pre></div></li>
<li>
<p>03 <code>decltype</code> 의 작동 방식</p>
<ul>
<li>
<p><code>decltype</code> 은 항상 변수나 표현식의 형식을 아무 수정 없이 보고한다.</p>
</li>
<li>
<p><code>decltype</code> 은 형식이 <code>T</code>이고 이름이 아닌 lvalue 표현식에 대해서는 항상 <code>T&amp;</code> 형식을 보고한다.</p>
</li>
<li>
<p>C++14 에서는 <code>decltype(auto)</code> 를 지원한다.</p>
</li>
<li>
<p>일반적인 동작 예제</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// decltype(i): const int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span> <span class="c1">// decltype(w): const Widget&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="c1">// decltype(f): bool(const Widget&amp;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>              <span class="c1">// decltype(Point::x): int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                        <span class="c1">// decltype(Point::y): int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>                <span class="c1">// decltype(w): Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="p">...</span>            <span class="c1">// decltype(f(w)): bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">vector</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>           <span class="c1">// decltype(v): vector&lt;int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">...</span>       <span class="c1">// decltype(v[0]): int&amp;
</span></span></span></code></pre></div></li>
<li>
<p>후행 반환 형식 (trailing return type) 에 사용</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>반환 형식을 auto 로 사용할 때의 문제, <code>decltype(auto)</code> C++14</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">authAndAccess</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// Compile error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="c1">// 여기서 c[i]의 auto 연역에서 참조성이 무시된다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="c1">// 반환형식은 int&amp; 가 아닌 int이므로 rvalue에 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="c1">// 값을 쓰려 하기 때문에 컴파일 오류가 발생한다.
</span></span></span></code></pre></div><p>위의 문제를 해결하기 위해 <code>auto</code> 대신 아래와 같이 <code>decltype(auto)</code> 를 사용해야 한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>           <span class="c1">// decltype 연역에 의해 T&amp; 를 반환
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 비슷한 방식으로 decltype 은 참조성을 유지하기 위해 
</span></span></span><span class="line"><span class="cl"><span class="c1">// auto 대신 아래와 같이 사용 가능하다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">cw</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">myWidget1</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>           <span class="c1">// myWidget1 의 형식: Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">myWidget2</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span> <span class="c1">// myWidget2 의 형식: const Widget&amp;
</span></span></span></code></pre></div><p>위의 경우는 반환값을 lvalue로 반환하지만 rvalue로도 반환하게 하기 위해서는 아래와 같이 보편 참조를 이용하여 작성해야한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// for C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>int x;</code> 일 때 C++ 에서는 <code>(x)</code>는 왼값이기 때문에 <code>decltype((x))</code> 는 <code>int&amp;</code>가 된다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>         <span class="c1">// f1() 은 int 를 반환
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>       <span class="c1">// f2()는 int&amp;를 반환
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>04 type 을 debugging 하는 방법</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// STL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">getX</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Boost Library
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;boost/type_index.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span></code></pre></div></li>
</ul>
<h2 id="auto">auto</h2>
<ul>
<li>05 명시적 형식 선언보다는 <code>auto</code> 를 선호하자.
<ul>
<li>
<p>초기화를 빼먹지 않게 된다.</p>
</li>
<li>
<p>람다 표현식에서 사용 가능 C++14</p>
</li>
<li>
<p>compiler 만 알던 형식을 지정할 수 있다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">derefUPLess</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div><p><code>auto</code>로 선언한 함수 포인터가 <code>std::function</code> 로 선언한 함수포인터가 메모리를 덜 사용할 수 있다. <code>std::function</code> 을 사용할 경우, 클로저는 <code>std::function template</code>의 인스턴스화 된다. 이때 클로저의 크기가 제한된 메모리를 넘어갈 경우 힙 메모리를 할당하여 클로저를 저장하여 더 많은 메모리 사용을 야기한다.</p>
<p>→ <code>std::function</code>: 메모리 사용 증가</p>
<p>std::function은 인라인화가 제한된다. 간접 함수 호출 방식의 구현상 느리다.</p>
<p>→ <code>std::function:</code> 느리다.</p>
</li>
<li>
<p>이식성, 효율성 문제를 유발할 수 있는 형식 불일치의 방생이 거의 없다.</p>
<ul>
<li><code>std::unordered_map</code> 의 key 부분이 <code>const</code>이다. <code>auto</code> 를 이용해 신경쓰지 않고 구현 가능하다.</li>
<li>의도하지 않게 발생하는 형변환이 방지된다.</li>
</ul>
</li>
<li>
<p>코드가 짧아진다.</p>
</li>
<li>
<p>원치 않는 형식 연역이 발생할 수 있다.</p>
</li>
</ul>
</li>
<li>06 <code>auto</code>가 원치 않은 형식으로 연역될 때엔는 명시적 형식의 초기치를 사용하자.
<ul>
<li><code>std::vector&lt;bool&gt;::reference</code> 와 같은 대리자 클래스(proxy class)의 객체 사용시 <code>auto</code> 를 사용할 경우 의도하지 않은 형태로 연역 될 수 있다.
<ul>
<li>
<p><code>std::vector&lt;bool&gt;</code> 의 <code>operator[]</code> 가 돌려주는 건은 컨테이너 요소의 참조가 아니라 <code>std::vector&lt;bool&gt;::reference</code>형식의 객체이다. (<code>std::vector&lt;bool&gt;::reference</code>은 <code>bool</code> 타입으로의 형변환 기능을 포함한다.)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vecBool</span> <span class="o">=</span> <span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">elemBool1</span> <span class="o">=</span> <span class="n">vecBool</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// elemBool1 은 bool 타입이 아니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">elemBool2</span> <span class="o">=</span> <span class="n">vecBool</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// elemBool2 은 bool 타입이다.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 명시적 형변환을 이용
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">elemBool3</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vecBool</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> 
</span></span><span class="line"><span class="cl">														 <span class="c1">// elemBool3 는 bool 타입
</span></span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="modern-c">Modern C++</h2>
<ul>
<li>
<p>07 객체 생성 시 괄호<code>()</code>와 중괄호<code>{}</code></p>
<ul>
<li>
<p>일반적으로 중괄호를 사용하는 것이 명확하고 잘 동작할 수 있다.</p>
</li>
<li>
<p>Norrow conversion 이 방지된다.</p>
</li>
<li>
<p><code>std::vector</code>와 같이 괄호와 중괄호에 따라 다른 생성자가 호출될 수 있다.</p>
</li>
<li>
<p>생성자에 <code>std::initializer_list</code>를 인수로 받는 함수가 있을 경우 이 생성자의 호출이 강제되어 컴파일 오류가 생길 수 있다</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">Widget</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">bl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// 세번째 생성자 호출로 인한 compile error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">// (narrow conversion 이 필요하기 때문)
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>08 <code>0</code> 과 <code>NULL</code> 보다 <code>nullptr</code> 을 선호하자.</p>
<ul>
<li><code>0</code> 은 <code>int</code> 이기 때문에 pointer 를 인수로 받는 함수의 overloading 시 문제가 생길 수 있음을 주의해야 한다.</li>
</ul>
</li>
<li>
<p>09 <code>typedef</code> 보다 <code>using</code> 을 선호하자.</p>
<ul>
<li><code>using</code> 은 템플릿화를 지원한다.</li>
</ul>
</li>
<li>
<p>10 <code>enum</code> (unscoped enum)보다 <code>enum class</code> (scoped enum) 을 선호하자.</p>
<ul>
<li>scoped enum 은 반드시 명시적 형변환이 필요하다.</li>
<li>scoped enum 의  defualt 바탕형식은 int 이고 unscoped enum 은 defualt 바탕형식이 없다.</li>
<li>바탕형식이 없는 unscoped enum 은 전방선언이 불가하다.</li>
</ul>
</li>
<li>
<p>11 함수 삭제 (<code>delete</code>)</p>
<ul>
<li>
<p><code>class</code> 의 원치 않는 인스턴스를 방지</p>
<p>원치 않는 복사를 방지할 수 있다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>             <span class="c1">// 복사 생성자 삭제
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">// 복사 대입 연산자 삭제
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span></code></pre></div></li>
<li>
<p><code>template</code> 의 원치 않는 인스턴스를 방지</p>
<p>포인터를 인자로 받는 <code>template</code> 의 원치 않는 인스턴스 방지 (일반 포인터가 아닌 <code>void*</code> 와 <code>char*</code> 를 인스턴스화 하지 않기 위해 사용 가능)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">processPointer</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>
<p>public 함수의 정의를 방지</p>
<p>private 으로 정의된 함수는 클라이언트 코드에서 debugging이 힘들어 진다.</p>
</li>
</ul>
</li>
<li>
<p>12 함수 재정의,  <code>override</code> 사용, 참조 한정사 (reference qualifier)</p>
<ul>
<li>
<p>함수 재정의 요건</p>
<ol>
<li>base class 가 가상함수 (virtual)</li>
<li>base class 와 derived class 의 함수명이 동일</li>
<li>base class 와 derived class 의 매개변수의 형식들이 동일</li>
<li>base class 와 derived class 의 const 성이 동일</li>
<li>base class 와 derived class 의 exception specification이 동일</li>
<li>base class 와 derived class 의 reference qualifier 가 동일</li>
</ol>
</li>
<li>
<p>override 사용시 정의되지 않은 함수(또는 잘못 재정의된 함수)에 대한 에러가 발생 → 컴파일 단계에서 문제 확인이 가능</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f3</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span> <span class="c1">// lvalue reference qualifier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                       <span class="c1">// *this 가 lvalue 일때만 적용된다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f4</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// compile 되는 잘못된 코드 (함수 재정의가 되지 않는다.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f3</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span> <span class="c1">// rvalue reference qualifier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// *this 가 rvalue 일때만 적용된다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f4</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// compile 되지 않는 잘못된 코드
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Derived2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f3</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f4</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// compile 되는 올바른 코드 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Derived3</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 	
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 	
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span> 	
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f3</span><span class="p">()</span> <span class="o">&amp;</span> <span class="k">override</span><span class="p">;</span> 	
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f4</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>13 <code>iterator</code> 보다는 <code>const_iterator</code> 를 선호하자.</p>
<p><code>begin, end, rbegin</code> 보다는 <code>cbegin, cend, crbegin</code> 을 선호하자.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="mi">1983</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">1998</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">findAndInsert</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">target_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">insert_value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">;</span> <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">;</span>   <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">cbegin</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                      <span class="n">cend</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                      <span class="n">target_value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">container</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">insert_value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>14 예외 명세 <code>noexcept</code></p>
<ul>
<li>함수의 인터페이스로 함수가 예외를 방출하지 않을 경우 <code>noexcept</code>로 선언할 수 있다.</li>
<li><code>noexcept</code> 로 호출된 함수는 컴파일과정에서 최적화 될 여지가 많다.</li>
<li><code>noexcept</code>는 이동 연산들과 swap, 메모리 해제 함수들, 소멸자들에 특히나 유용하다.</li>
<li>하지만 대부분의 함수는 <code>noexcept</code>가 아닌 예외에 중립적이다.
<ul>
<li>내가 쓴 함수가 예외를 방출하지 않는다면 <code>noexcept</code>로 선언</li>
<li>함수내 사용하는 third party library가 있을 경우, 확인하여 적용</li>
</ul>
</li>
</ul>
</li>
<li>
<p>15 가능하면 항상 <code>constexpr</code>을 선호하자.</p>
<ul>
<li>컴파일 시점에서 함수, 변수들을 사용할 수 있게 해준다.</li>
<li>함수의 경우 인자들이 컴파일 시점에서 알 수 있는 경우에는 컴파일 시점에서 동작하고 그렇지 않을 경우에는 실행 시점에서 동작한다. → 사용할 수 있는 문맥이 넓다.</li>
<li>C++11은  constexpr 함수의 제약이 있다. (하지만 C++14에서는 폭넓게 사용 가능하다. )
<ul>
<li>리터럴 형식(void가 아닌 함수)이어야 한다.</li>
<li>멤버 변수 수정이 불가하다.</li>
<li>실행가능 문장이 많아야 하나이다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>16 const 멤버 함수를 스레드에 안전하게 작성하자.</p>
<ul>
<li><code>std::mutex</code>, <code>std::atomic</code> 을 이용하여 스레드에 안전하게 작성하자.
<ul>
<li><code>std::atomic</code>: 하나의 변수 또는 메모리 장소를 다룰 때</li>
<li><code>std::mutex</code>: 둘 이상의 변수 또는 메모리 장소를 다룰 때</li>
<li><code>std::mutex</code>, <code>std::atomic</code> 을 멤버 변수로 정의하면 클래스의 이동, 복사가 방지된다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>17 특수 멤버 함수 (special member function)</p>
<ul>
<li>컴파일러가 스스로 작성하는 함수
<ul>
<li>기본 생성자</li>
<li>소멸자</li>
<li>복사 생성자와 복사 배정 연산자
<ul>
<li>복사 연산이 명시적으로 선언되지 않은 경우 자동으로 작성된다.</li>
<li>이동 연산이 하나라도 선언되면 삭제된다.</li>
</ul>
</li>
<li>이동(move) 생성자와 이동 배정(move assignment) 연산자
<ul>
<li>이동 연산, 복사 연산, 소멸자가 명시되지 않은 경우 자동으로 작성된다.</li>
</ul>
</li>
</ul>
</li>
<li>Rule of Three
<ul>
<li>복사 생성자, 복사 배정 연산자, 소멸자 중 하나라도 선언하면 나머지 둘도 선언해야 한다.</li>
</ul>
</li>
<li>Rule of Five
<ul>
<li>Rule of Three 에서 이동, 이동 배정 연산 추가</li>
<li>.</li>
<li>.</li>
<li>.</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="smart-pointer">Smart Pointer</h2>
<ul>
<li>
<p>18 소유권 독점 자원의 관리에는 <code>std::unique_ptr</code>를 사용하자.</p>
<ul>
<li>독점 소유권 의미론을 가진다. (move only)</li>
<li>custom deleter 를 지정할 수 있다.
<ul>
<li>상태가 없는 람다 함수를 이용하지 않고, 함수나 상태가 있는 삭제자를 사용하면 std::unique_ptr 의 크기가 커진다.</li>
</ul>
</li>
<li>std::unique_ptr 에서 std::shared_ptr 로 손쉽게 변환 가능하다.</li>
<li>사용 예제 - 팩터리 함수, pimpl 관용구
<ul>
<li>계층구조에서 팩터리 함수의 반환형식으로 사용</li>
<li>Pimpl 관용구에 사용</li>
</ul>
</li>
</ul>
</li>
<li>
<p>19 소유권 공유 자원의 관리에는 <code>std::shared_ptr</code>를 사용하자.</p>
<ul>
<li>
<p>std::shared_ptr는 임의의 공유자원의 수명을 편리하게 관리할 수 있게 한다.</p>
</li>
<li>
<p>대체로 std::shared_ptr 객체는 그 크기가 std::unique_ptr객체의 두 배이며, 제어 블록에 관련된 추가 부담을 유발하며 원자적 참조 횟수 조작을 요구한다.</p>
</li>
<li>
<p>자원은 기본적으로 delete로 파괴되나 커스텀 삭제자도 지원된다.</p>
<ul>
<li>std::unique_ptr 과는 다르게 커스텀 삭제자의 형식에 아무런 영향을 받지 않는다</li>
</ul>
</li>
<li>
<p>raw pointer 형식의 변수로부터 std::shared_ptr를 생성하는 일은 피하자.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">pw</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Widget</span><span class="p">;</span>                    <span class="c1">// create raw pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span>         <span class="c1">// Bad code!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp2</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span> <span class="c1">// Better code!
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>20 <code>std::shared_ptr</code>처럼 작동하되 대상을 잃을 수도 있는 포인터가 필요하면 <code>std::weak_ptr</code>를 사용하자.</p>
<ul>
<li>캐싱, 관찰자 목록, <code>std::shared_ptr</code>순환 고리 방지에 사용 가능</li>
</ul>
</li>
<li>
<p>21 <code>new</code> 를 직접 사용하는 것보다 <code>std::make_unique</code>, <code>std::make_shared</code>를 선호하자.</p>
<ul>
<li><code>new</code> 를 직접 사용할때보다 소스코드의 중복 여지가 없어지고 예외 안전성이 향상되고 더 작고 빠른 프로그램이 산출된다.</li>
<li>중괄호로 초기치를 전달할 수 없으며 custom deleter 를 지정할 수 없다.</li>
<li>예외적으로 <code>new</code> 를 선호해야 하는 상황
<ul>
<li>메모리가 넉넉하지 않은 상황에서 큰 객체를 다루는 경우</li>
<li>커스텀 메모리 관리 기능을 가진 클래스를 다루는 경우</li>
<li><code>std::weak_ptr</code> 가 <code>std::shared_ptr</code> 보다 오래 살아남는 경우</li>
</ul>
</li>
</ul>
</li>
<li>
<p>22 Pimpl 관용구(Pointter to implementation idiom)를 사용할 때에는 특수 멤버 함수들을 구현 파일에서 정의하자.</p>
<ul>
<li>
<p>Pimpl 관용구는 클래스 구현과 클래스 클라이언트 사이의 컴파일 의존성을 줄임으로써 빌드 시간을 감소시킨다.</p>
</li>
<li>
<p>std::unique_ptr형식의 pImpl 포인터를 사용할 때에는</p>
<ul>
<li>특수 멤버 함수들을 클래스 헤더에 선언하고 구현 파일에서 구현해야 한다.</li>
<li>컴파일러가 기본으로 작성하는 함수 구현들을 그대로 사용할 경우에도 구현 파일에서 구현해야 한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// widget.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>            
</span></span><span class="line"><span class="cl">                        <span class="c1">// 복사 생성자; 선언만 한다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">                        <span class="c1">// 복사 배정 생성자; 선언만 한다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// widget.cpp 구현파일
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span>        <span class="c1">//Widget 객체에 필요한 자료 멤버들 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Gadget</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(){}</span> <span class="c1">// 생성자
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>  <span class="c1">// pImpl 의 deep copy를 위한 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span>                   <span class="c1">// 복사 생성자
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">)</span> <span class="n">pImpl</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::~</span><span class="n">Widget</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 기본 구현 소멸자
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">Widget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="c1">// 복사 배정 연산자
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">)</span> <span class="n">pImpl</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">                             <span class="c1">// rhs 가 nullptr 이면 pImpl reset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pImpl</span><span class="p">)</span> <span class="n">pImpl</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                             <span class="c1">// pImpl 가 nullptr 이면 깊은 복사 생성
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">else</span> <span class="o">*</span><span class="n">pImpl</span> <span class="o">=</span> <span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h2 id="rvalue-reference-move-semantics-perfect-forwarding">Rvalue Reference, Move Semantics, Perfect Forwarding</h2>
<ul>
<li>move semantics
<ul>
<li>중요한 이유
<ul>
<li>복사 등이 일어났을때 비용이 얼마나 드는지 명확하게 알 수 있다. (이동 생성을 통해 비용을 줄일 수 있다.)</li>
</ul>
</li>
</ul>
</li>
<li>오른값 (rvalue)
<ul>
<li>이동 연산이 가능</li>
<li>함수가 돌려준 임시 객체</li>
<li>주소를 취할 수 없다.</li>
</ul>
</li>
<li>왼값 (lvalue)
<ul>
<li>이동 연산이 불가능</li>
<li>이름이나 포인터, 왼값 참조를 통해서 지칭할 수 있는 객체</li>
<li>주소를 취할 수 있다.</li>
</ul>
</li>
<li>23 <code>std::move</code> 와 <code>std::forward</code>
<ul>
<li><code>std::move</code> 와 <code>std::forward</code> 는 둘 다 실행시점에서 아무 일도 하지 않고 (조건부)캐스팅만 한다.</li>
<li><code>std::move</code> 는 무조건 rvalue로 캐스팅을 수행한다.</li>
<li><code>std::forward</code> 는 주어진 인수가 오른값에 묶인 경우에만 그것을 오른값으로 캐스팅한다.</li>
</ul>
</li>
<li>24 보편 참조(universal reference)
<ul>
<li>보편 참조는 오른값으로 초기화 되면 오른값 참조, 왼값으로 초기화 되면 왼값 참조가 된다.</li>
<li>함수 템플릿 매개변수의 형식이 <code>T&amp;&amp;</code>형태이고 <code>T</code>가 연역된다면, 또는 객체를 <code>auto&amp;&amp;</code>로 선언한다면, 그 매개변수나 객체는 보편참조이다.</li>
<li>형식 선언의 형태가 정확히 <code>형식&amp;&amp;</code>가 아니면 또는 <code>형식</code> 의 연역이 일어나지 않으면 <code>형식&amp;&amp;</code>은 오른값 참조이다.</li>
</ul>
</li>
<li>25 오른값 참조에는 <code>std::move</code> 를, 보편 참조에는 <code>std::forward</code> 를 사용하자.
<ul>
<li>결과를 값 전달 방식으로 돌려주는 함수가 오른값 참조나 보편 참조를 돌려줄 때에도 각각 std::move나 std::forward를 적용하자.</li>
<li>컴파일러가 반환값 최적화를 수행할 수 있는 지역 객체에 대해서는 절대 std::move 나 std::forward를 적용하지 말아야 한다.</li>
</ul>
</li>
<li>26 보편 참조에 대한 overloading 을 피하자.
<ul>
<li>의도치 않게 보편 참조의 overloading 함수가 호출되는 경향이 크다.</li>
</ul>
</li>
<li>27 보편 참조에 대한 overloading 대신 사용할 수 있는 방법
<ul>
<li>함수의 이름을 다르게 하기</li>
<li>매개변수를 const 에 대한 lvalue reference 로 전달</li>
<li>꼬리표 배분</li>
<li><code>std::enable_if</code> 를 이용해서 템플릿의 인스턴스화를 제한할 수 있다. (컴파일러가 보편 참조 <code>overloading</code>을 사용하는 조건을 제어할 수 있다.)</li>
</ul>
</li>
<li>28 참조 축약을 숙지하라
<ul>
<li>참조 축약은 템플릿 인스턴스화, <code>auto</code> 형식 연역, <code>typedef</code> 와 별칭 선언의 지정 및 사용, <code>decltype</code>의 지정 및 사용시 발생한다.</li>
</ul>
</li>
<li>29 이동 연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라.</li>
<li>30 완벽 전달이 실패하는 경우들을 잘 알아두라
<ul>
<li>완벽 전달(perfect forwarding)은 템플릿 형식 연역이 실패하거나 틀린 형식을 연역했을 때 실패한다.</li>
<li>인수가 중괄호 초기치이거나 <code>0</code>또는 <code>NULL</code>로 표현된 널 포인터, 선언만 된 정수 <code>static const</code> 및 <code>constexpr</code> 자료 멤버, 템플릿 및 중복적재된 함수 이름, 비트필드이면 완벽 전달이 실패한다.</li>
</ul>
</li>
</ul>
<h2 id="람다-표현식">람다 표현식</h2>
<ul>
<li>lambda expression: 람다 표현식, 소스코드의 일부</li>
<li>closure: 람다에 의해 만들어진 실행 시점의 객체</li>
<li>closure class: closure를 만드는데 쓰인 클래스</li>
<li>31 기본 갈무리(capture) 모드를 피하라
<ul>
<li>기본 참조 갈무리는 참조가 대상을 잃을 위험이 있다.</li>
<li>기본 값 갈무리는 포인터가 대상을 잃을 수 있으며, 람다가 자기 완결적이라는 오해를 부를 수 있다.</li>
</ul>
</li>
<li>32 객체를 클로저 안으로 이동하려면 초기화 갈무리를 사용하라.
<ul>
<li>C++14에서는 초기화 갈무리를 사용하라.</li>
<li>C++11 에서는 직접 작성한 <code>class</code> 나 <code>std::bind</code>로 초기화 갈무리를 흉내 낼 수 있다.</li>
</ul>
</li>
<li>33 <code>std::forward</code>를 통해서 전달할 <code>auto&amp;&amp;</code> 매개변수에는 <code>decltype</code> 을 사용하라.</li>
<li>34 <code>std::bind</code> 보다 람다를 선호하라.
<ul>
<li>람다가 읽기 쉽고 표현력이 좋다.</li>
<li>람다는 함수를 인라인화 하여 더 효율적일 수 있다.</li>
<li>객체를 템플릿화된 함수 호출 연산자에 묶으려 할 때 <code>std::bind</code> 가 유용할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="동시성concurrency-api">동시성(concurrency) API</h2>
<ul>
<li>35 스레드(thread) 기반 프로그래밍보다 과제(task) 기반 프로그래밍을 선호하라.
<ul>
<li><code>std::thread</code> API에서는 비동기적으로 실행된 함수의 반환값을 직접 얻을 수 없으며, 만일 그런 함수가 예외를 던지면 프로그램이 종료한다.</li>
<li>스레드 기반 프로그래밍에서는 스레드 고갈, 과다구독, 부하 균형화, 새 플랫폼으로의 적응을 개발자가 직접 처리해야 한다.</li>
<li><code>std::async</code> 와 기본 시동 방침을 이용한 과제 기반 프로그래밍은 그런 대부분의 문제를 알아서 처리해준다.</li>
</ul>
</li>
<li>36 비동기성이 필수일 때에는 <code>std::launch::async</code> 를 지정하라.
<ul>
<li><code>std::async</code> 의 기본 동작은 <code>std::launch::async || std::launch::deferred</code> 이다.
<ul>
<li><code>std::launch::async</code>: 함수를 반드시 비동기적으로 다른 스레드에서 실행한다.</li>
<li><code>std::launch::deferred</code>: <code>std::async</code>가 돌려준 미래 객체(<code>std::future</code>)에 대해 <code>get</code> 이나 <code>wait</code>가 호출될 때까지 지연(deferred)된다.</li>
</ul>
</li>
</ul>
</li>
<li>37 <code>std::thread</code>들은 모든 경로에서 합류 불가능하게 만들어라.
<ul>
<li>모든 경로에서 std::thread를 합류 불가능으로 만들어라.</li>
<li>소멸 시 join 방식은 디버깅하기 어려운 성능 이상으로 이어질 수 있다.</li>
<li>소멸 시 detach 방식은 디버깅하기 어려운 미정의 행동으로 이어질 수 있다.</li>
<li>자료 멤버 목록에서 std::thread객체를 마지막에 선언하라.</li>
</ul>
</li>
<li>38 스레드 핸들 소멸자들의 다양한 행동 방식을 주의하라.
<ul>
<li>미래 객체의 소멸자는 그냥 미래 객체의 자료 멤버들을 파괴할 뿐이다.</li>
<li><code>std::async</code>를 통해 시동된 비지연 과제에 대한 공유 상태를 참조하는 마지막 미래 객체의 소멸자는 그 과제가 완료될 때까지 차단된다.</li>
</ul>
</li>
<li>39 단발성 사건 통신에는 void 미래 객체를 고려하라.
<ul>
<li>뮤텍스, 조건변수, 플래그 등을 고려할 수 있다.</li>
<li><code>std::promise</code>와 미래 객체를 사용할 수 있다.</li>
</ul>
</li>
<li>40 동시성에는 <code>std::atomic</code>을 사용하고 <code>volatile</code>은 특별한 메모리에 사용하라.
<ul>
<li><code>std::atomic</code>은 뮤텍스 보호 없이 여러 스레드가 접근하는 자료를 위한 것</li>
<li><code>volatile</code>은 읽기와 기록을 최적화로 제거하지 말아야 하는 메모리를 위한 것으로 memory mapped IO 등에 사용할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="다듬기">다듬기</h2>
<ul>
<li>41 이동이 저렴하고 항상 복사되는 복사 가능 매개변수에 대해서는 값 전달을 고려하라.</li>
<li>42 삽입 대신 생성 삽입(emplace)을 고려하라.</li>
</ul>
<h1 id="reference">Reference</h1>
<ul>
<li>
<p>기본적으로 Effective Modern C++ (스콧 마이어스 지음, 류광 옮김)도서를 참고</p>
</li>
<li>
<p><a href="https://modoocode.com/302">std::forward</a></p>
</li>
</ul>



<h3>이 시리즈의 게시물</h3>
<ul>
  
    <li><a href="../../study/no-raw-loops-yes-stl-algorithms-17cb7499a6464a30a9880cdc161e05b9/">No Raw Loops! Yes STL Algorithms!</a></li>

  
    <li><a href="../../study/effective-modern-c&#43;&#43;/">Effective Modern C&#43;&#43;</a></li>

  
</ul>
</div>
    <div class="post__footer">
      

      
        <span><a class="tag" href="../../tags/c&#43;&#43;/">C&#43;&#43;</a><a class="tag" href="../../tags/%EB%8F%85%EC%84%9C/">독서</a></span>




      
    </div>

    <div id="comment">
          <h2>댓글</h2>
          <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "kyungpyo-kim" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </div>
  </div>


      </main>
    </div><footer class="footer footer__base">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        Kyungpyo Kim 2014-2022

      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="../../js/medium-zoom.min.602bd2014468bd348112e2aa24f595c530d257a4ed6c335d7baaa6ac9a7ca6fb.js"
    integrity="sha256-YCvSAURovTSBEuKqJPWVxTDSV6TtbDNde6qmrJp8pvs="
    crossorigin="anonymous"
  ></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-150383923-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</body>
</html>
